/**
 * Furi - Fast Uniform Resource Identifier.
 *
 * The Fast and Furious Node.js Router.
 * Copyright(c) 2016, 2025 Rajinder Yadav.
 *
 * Labs DevMentor.org Corp. <info@devmentor.org>
 * This code is released as-is without warranty under the "GNU GENERAL PUBLIC LICENSE".
 */
import { IncomingMessage, ServerResponse } from 'node:http';
import { Socket } from "node:net";
import { ApplicationContext } from './application-context.js';
import { Furi } from './furi.js';
/**
 * API Version.
 */
export declare const API_VERSION: string;
/**
 * Logging helper functions.
 */
export declare const LOG_DEBUG: (msg: string) => void;
export declare const LOG_INFO: (msg: string) => void;
export declare const LOG_LOG: (msg: string) => void;
export declare const LOG_WARN: (msg: string) => void;
export declare const LOG_ERROR: (msg: string) => void;
export type LoggerMode = 'buffer' | 'stream';
/**
 * Map types for different indexed access.
 */
export interface MapOf<T1> {
    [key: string]: T1;
}
/**
 * Query parameter types.
 */
export type QueryParamTypes = string | string[] | number;
/**
 * Middleware function signature..
 */
export type Middleware = () => void;
/**
 * Function prototype for Request Handler callback function.
 *
 * @param request: HttpRequest
 * @param response: HttpResponse
 * @return boolean | void - return false to cancel remaining handlers.
 *
 * When multiple request handlers are passed in as an array,
 * any one may return false to prevent the remaining handlers from getting executed.
 */
export type HandlerFunction = (ctx: ApplicationContext, next: Middleware) => any;
/**
 * Static route handler callback functions.
 */
export interface StaticRouteCallback {
    callbacks: HandlerFunction[];
}
/**
 * Named route handler callback functions.
 * The 'key' is a regex string, with grouping for named segments.
 * the 'pathNames' is used by  the fast match algorithm, when useRegex is false,
 * otherwise the 'key' is use to determine if a route matches.
 *
 * @see createNamedRouteSearchKey for details on how 'key' is created.
 * @see attachPathParamsToRequestIfExists for details on how 'params' is created.
 * @see fastPathMatch for how the path is matched against 'pathNames'.
 */
export interface NamedRouteCallback {
    useRegex: boolean;
    pathNames: string[];
    key: string;
    params: string[];
    callbacks: HandlerFunction[];
}
/**
 * Maps URI to named params and handler callback functions.
 *
 * Matching Rules:
 * For URI direct matches, the callbacks will be found in uri_map.
 * For URI with named segments, the callbacks will be found under named_param.
 *
 * The key for staticRouteMap will be a path string.
 * The key for namedRoutePartitionMap will be the bucket value, which is a count of path segements.
 */
export interface RouteMap {
    staticRouteMap: MapOf<StaticRouteCallback>;
    namedRoutePartitionMap: MapOf<NamedRouteCallback[]>;
}
/**
 * Enumerated keys for HTTP Maps. The keys are used to partition
 * HTTP methods, to optimized lookup.
 */
export declare const HttpMapIndex: {
    MIDDLEWARE: number;
    GET: number;
    POST: number;
    PUT: number;
    PATCH: number;
    DELETE: number;
};
/**
 * Log level string litaral values for log messages and configuration.
 */
export declare const LogLevels: {
    DEBUG: string;
    INFO: string;
    LOG: string;
    WARN: string;
    ERROR: string;
    CRITICAL: string;
    FATAL: string;
};
/**
 * Log level ordinal values use for filtering log messages.
 */
export declare const LogLevelsRank: {
    DEBUG: number;
    INFO: number;
    LOG: number;
    WARN: number;
    ERROR: number;
    CRITICAL: number;
    FATAL: number;
};
/**
 * Converts a log level string to its ordinal value to help with log filtering.
 *
 * @param logLevel - The log level as a string.
 * @returns Log level ordinal value.
 */
export declare function mapToLogLevelRank(logLevel: string): number;
/**
 * HTTP Request object extending Node.js IncomingMessage.
 */
export declare class HttpRequest extends IncomingMessage {
    params: MapOf<string | number>;
    query: URLSearchParams | null;
    sessionData: MapOf<any>;
    app: Furi | null;
    constructor(incomingMessage: Socket);
    constructor(incomingMessage: IncomingMessage);
}
/**
 * HTTP Response object extending Node.js ServerResponse.
 */
export declare class HttpResponse extends ServerResponse<IncomingMessage> {
}
/**
 * Furi Server Configuration properties.
 * The properties are assigned default values, but can be overridden,
 * either from code or environment variables, or a '.env' file.
 */
export interface FuriConfig {
    server: {
        env: string;
        port: number;
        host: string;
        callback: null | (() => void);
    };
    logger: {
        enabled: boolean;
        terminal: boolean;
        flushPeriod: number;
        logFile: string;
        maxCount: number;
        mode: LoggerMode;
        level: string;
    };
}
/**
 * Base class for Class based router handlers.
 */
export declare abstract class BaseRouterHandler {
    abstract handle(ctx: ApplicationContext, next: Middleware): any;
}
/**
 * Generic Constructor function.
 */
export type RouterHanderConstructor<T> = {
    new (...args: any[]): T;
};
/**
 * Router reuqest handler definition.
 */
export type Route = {
    path: string;
    method: string;
    controller: HandlerFunction | HandlerFunction[] | RouterHanderConstructor<BaseRouterHandler>;
};
/**
 * Router configuration.
 */
export type RouterConfig = {
    middleware?: HandlerFunction[];
    routes?: Route[];
};
/**
 * Export type alias for Routes to be used by developers.
 */
export type Routes = RouterConfig;
/**
 * Helper function to check type Routes.
 * Properties 'middleware' or 'routes' are optional, but not both.
 */
export declare function isTypeRouterConfig(value: unknown): value is RouterConfig;
/**
 * Create and instance of the class and return bound handler function.
 *
 * @param ClassRef
 * @returns handler function bound to instace of the class.
 */
export declare function ClassHandler(ClassRef: unknown): HandlerFunction;
//# sourceMappingURL=types.d.ts.map