/**
 * Furi - Fast Uniform Resource Identifier.
 *
 * The Fast and Furious Node.js Router.
 * Copyright(c) 2016, 2025 Rajinder Yadav.
 *
 * Labs DevMentor.org Corp. <info@devmentor.org>
 * This code is released as-is without warranty under the "GNU GENERAL PUBLIC LICENSE".
 */
import { IncomingMessage, ServerResponse, } from 'node:http';
import { Furi } from './furi.js';
/**
 * API Version.
 */
export const API_VERSION = '0.2.9';
/**
 * Logging helper functions.
 */
export const LOG_DEBUG = (msg) => { if (Furi.fastLogger) {
    Furi.fastLogger.info(msg);
} };
export const LOG_INFO = (msg) => { if (Furi.fastLogger) {
    Furi.fastLogger.info(msg);
} };
export const LOG_LOG = (msg) => { if (Furi.fastLogger) {
    Furi.fastLogger.info(msg);
} };
export const LOG_WARN = (msg) => { if (Furi.fastLogger) {
    Furi.fastLogger.info(msg);
} };
export const LOG_ERROR = (msg) => { if (Furi.fastLogger) {
    Furi.fastLogger.info(msg);
} };
/**
 * Enumerated keys for HTTP Maps. The keys are used to partition
 * HTTP methods, to optimized lookup.
 */
export const HttpMapIndex = {
    MIDDLEWARE: 0,
    GET: 1,
    POST: 2,
    PUT: 3,
    PATCH: 4,
    DELETE: 5
};
/**
 * Log level string litaral values for log messages and configuration.
 */
export const LogLevels = {
    DEBUG: 'DEBUG',
    INFO: 'INFO',
    LOG: 'LOG',
    WARN: 'WARN',
    ERROR: 'ERROR',
    CRITICAL: 'CRITICAL',
    FATAL: 'FATAL'
};
/**
 * Log level ordinal values use for filtering log messages.
 */
export const LogLevelsRank = {
    DEBUG: 0,
    INFO: 1,
    LOG: 2,
    WARN: 3,
    ERROR: 4,
    CRITICAL: 5,
    FATAL: 6
};
/**
 * Converts a log level string to its ordinal value to help with log filtering.
 *
 * @param logLevel - The log level as a string.
 * @returns Log level ordinal value.
 */
export function mapToLogLevelRank(logLevel) {
    switch (logLevel.toUpperCase()) {
        case 'DEBUG':
            return LogLevelsRank.DEBUG;
        case 'INFO':
            return LogLevelsRank.INFO;
        case 'LOG':
            return LogLevelsRank.LOG;
        case 'WARN':
            return LogLevelsRank.WARN;
        case 'ERROR':
            return LogLevelsRank.ERROR;
        case 'CRITICAL':
            return LogLevelsRank.CRITICAL;
        case 'FATAL':
            return LogLevelsRank.FATAL;
        default:
            throw new Error(`Invalid log level: ${logLevel}`);
    }
}
/**
 * HTTP Request object extending Node.js IncomingMessage.
 */
export class HttpRequest extends IncomingMessage {
    constructor(incomingMessage) {
        super(incomingMessage instanceof IncomingMessage
            ? incomingMessage.socket :
            incomingMessage);
        Object.defineProperty(this, "params", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(this, "query", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
        });
        Object.defineProperty(this, "sessionData", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(this, "app", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
        });
        if (incomingMessage instanceof IncomingMessage) {
            Object.assign(this, incomingMessage);
        }
    }
}
/**
 * HTTP Response object extending Node.js ServerResponse.
 */
export class HttpResponse extends ServerResponse {
}
/**
 * Base class for Class based router handlers.
 */
export class BaseRouterHandler {
}
/**
 * Helper function to check type Routes.
 * Properties 'middleware' or 'routes' are optional, but not both.
 */
export function isTypeRouterConfig(value) {
    const middleswares = typeof value === 'object'
        && value !== null
        && 'middleware' in value
        && Array.isArray(value.middleware);
    const routes = typeof value === 'object'
        && value !== null
        && 'routes' in value
        && Array.isArray(value.routes);
    return middleswares || routes;
}
/**
 * Create and instance of the class and return bound handler function.
 *
 * @param ClassRef
 * @returns handler function bound to instace of the class.
 */
export function ClassHandler(ClassRef) {
    if (ClassRef && typeof ClassRef === 'function' && ClassRef.prototype instanceof BaseRouterHandler) {
        const ClassRouterHandlerRef = ClassRef;
        const instanceRef = new ClassRouterHandlerRef();
        return instanceRef.handle.bind(instanceRef);
    }
    throw new Error("Invalid class reference. Please provide a valid class that extends BaseRouterHandler.");
}
