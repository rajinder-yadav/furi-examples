/**
 * Furi - Fast Uniform Resource Identifier.
 *
 * The Fast and Furious Node.js Router.
 * Copyright(c) 2016, 2025 Rajinder Yadav.
 *
 * Labs DevMentor.org Corp. <info@devmentor.org>
 * This code is released as-is without warranty under the "GNU GENERAL PUBLIC LICENSE".
 */
// deno-lint-ignore-file no-explicit-any
import * as dntShim from "./_dnt.shims.js";
import * as fs from 'node:fs';
import * as http from 'node:http';
import process from "node:process";
import YAML from 'yaml';
import { FuriRouter } from './furi-router.js';
import { API_VERSION, LogLevels, LOG_INFO, LOG_ERROR, } from './types.js';
import { StoreState } from './state.js';
import { FastLogger } from './utils/fast-logger.js';
import { BodyParserFn, JSONBodyParserFn, UrlEncodedParserFn, } from './middlewares/body-parser/body-parser.js';
// Re-export types and classes for applications
export * from './types.js';
export * from './application-context.js';
export * from './furi-router.js';
export * from './utils/http-cookies-store.js';
export * from './utils/time-period.js';
export * from './middlewares/cors/cors.js';
/**
 * SIGINT (Signal Interrupt)
 * Signal Number: 2
 * Description: Sent to a process when the user types the interrupt character (usually Ctrl+C) at the terminal.
 * Default Action: Terminates the process.
 * Example: Stopping a running program from the terminal.
 */
process.once('SIGINT', () => {
    // Handler Linux signal to perform clean shutdown.
    Furi.shutDown(5000);
});
/**
 * Signal Number: 15
 * Description: A request to terminate a process. This signal can be caught and handled by the process.
 * Default Action: Terminates the process.
 * Example: kill <pid> to gracefully terminate a process.
*/
process.once('SIGTERM', () => {
    // Handler Linux signal to perform clean shutdown.
    Furi.shutDown(5000);
});
/**
 * Router Class, matches URI for fast dispatch to handler.
 */
export class Furi extends FuriRouter {
    constructor() {
        super();
        Object.defineProperty(this, "server", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
        });
        Object.defineProperty(this, "properties", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        // Shutdown cleanup handler callback.
        Object.defineProperty(this, "cleanupHandler", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
        });
        // Default server configuration.
        Object.defineProperty(this, "furiConfig", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {
                server: {
                    env: 'development',
                    port: 3030,
                    host: 'localhost',
                    callback: null,
                },
                logger: {
                    enabled: false,
                    terminal: false,
                    flushPeriod: 1000,
                    logFile: 'furi.log',
                    maxCount: 100,
                    mode: 'stream',
                    level: LogLevels.INFO,
                },
            }
        });
        // Read default configuration values.
        let { env, port, host, callback } = this.furiConfig.server;
        let { enabled, terminal, flushPeriod, maxCount, mode, logFile, level } = this.furiConfig.logger;
        /**
         * Read server configuration properties from furi.yaml or furi.yml file.
         */
        try {
            let data = null;
            if (fs.existsSync('./furi.yaml') && fs.statSync('./furi.yaml').isFile()) {
                data = fs.readFileSync('./furi.yaml', 'utf8');
            }
            else if (fs.existsSync('./furi.yml') && fs.statSync('./furi.yml').isFile()) {
                data = fs.readFileSync('./furi.yml', 'utf8');
            }
            if (data !== null) {
                // Server values.
                this.properties = YAML.parse(data);
                if (this.properties.server) {
                    port = this.properties.server.port ?? port;
                    host = this.properties.server.host ?? host;
                    env = this.properties.server.env ?? env;
                }
                // Logger values.
                if (this.properties.logger) {
                    enabled = this.properties.logger.enabled ?? enabled;
                    terminal = this.properties.logger.terminal ?? terminal;
                    flushPeriod = this.properties.logger.flushPeriod ?? flushPeriod;
                    maxCount = this.properties.logger.maxCount ?? maxCount;
                    mode = this.properties.logger.mode ?? mode;
                    logFile = this.properties.logger.logFile ?? logFile;
                    level = this.properties.logger.level?.toUpperCase() ?? level;
                }
                // Update configuration values.
                this.furiConfig = {
                    server: { env, port, host, callback },
                    logger: { enabled, terminal, flushPeriod, logFile, maxCount, mode, level },
                };
            }
            Furi.fastLogger = new FastLogger(process.cwd(), logFile, enabled, terminal, flushPeriod, maxCount, mode, level);
        }
        catch (error) {
            // Ignore and file errors.
            LOG_ERROR(`Furi::constructor error: ${JSON.stringify(error)}`);
        }
        this.furiConfig.server.callback = () => {
            const serverMessage = this.getServerStartupMessage();
            const serverInfoMessage = this.getServerInfoMessage();
            const loggerInfoMessage = this.getLoggerInfoMessage();
            const runtimeInfoMessage = this.getRuntimeMessage();
            if (Furi.fastLogger) {
                Furi.fastLogger.info(serverMessage);
                Furi.fastLogger.info(serverInfoMessage);
                Furi.fastLogger.info(runtimeInfoMessage);
                Furi.fastLogger.info(loggerInfoMessage);
            }
            console.log(serverMessage);
            console.log(serverInfoMessage);
            console.log(runtimeInfoMessage);
            console.log(loggerInfoMessage);
        };
    }
    /**
     * Class static method. Create instance of Router object.
     *
     * @returns Instance of class Furi.
     */
    static create() {
        // LOG_DEBUG(Furi.getApiVersion());
        return new Furi();
    }
    static info(message) {
        if (Furi.fastLogger) {
            Furi.fastLogger.info(message);
        }
    }
    /**
     * Perform clean shutdown.
     */
    static shutDown(exitTimer) {
        console.log();
        LOG_INFO('SIGINT signal received, goodbye!');
        LOG_INFO('Shutdown started...');
        // Close the HTTP server.
        // Close all Furi applications and their HTTP servers gracefully.
        Furi.httpServer.forEach((serverRef) => {
            LOG_INFO('Furi server shutting down...');
            if (serverRef.app.cleanupHandler) {
                LOG_INFO('Cleanup started...');
                serverRef.app.cleanupHandler();
                LOG_INFO('Cleanup completed.');
            }
            LOG_INFO('HTTP connection closing...');
            serverRef.http.close();
            LOG_INFO('HTTP connection closed.');
            LOG_INFO('Furi server shutdown completed.');
        });
        LOG_INFO('Shutdown completed.');
        if (Furi.fastLogger) {
            Furi.fastLogger.close();
        }
        // Delay to allow asynchronous processing to complete.
        setTimeout(() => {
            process.exit(1);
        }, exitTimer);
    }
    /**
     * Create a new router.
     * @return Instance of class FuriRouter.
     */
    static router() {
        return new FuriRouter();
    }
    /**
     * Get Router API version.
     *
     * @returns API version as a string.
     */
    static getApiVersion() {
        return `Furi (v${API_VERSION})`;
    }
    /**
     * Start server with specified configuration.
     *
     * @param serverConfig  Configuration object for the server.
     * @returns Instance of http.Server.
     */
    listen(serverConfig) {
        let { env, port, host, callback } = serverConfig.server;
        // Update running server config properties.
        if (env) {
            this.furiConfig.server.env = env;
        }
        if (port) {
            this.furiConfig.server.port = port;
        }
        if (host) {
            this.furiConfig.server.host = host;
        }
        if (callback) {
            this.furiConfig.server.callback = callback;
        }
        if (!callback) {
            callback = this.furiConfig.server.callback;
        }
        const server = http.createServer(this.handler());
        if (port && host && callback) {
            server.listen(port, host, callback);
        }
        else if (port && callback) {
            server.listen(port, callback);
        }
        else if (port && host) {
            server.listen(port, host);
        }
        else {
            server.listen(port);
        }
        return server;
    }
    /**
     * Starts the Furi server with default or provided configuration.
     *
     * @returns Instance of http.Server.
     */
    start(_callback) {
        this.server = this.listen(this.furiConfig);
        // Node.js HTTP server list used to perform a clean close before exiting the process.
        Furi.httpServer.push({ app: this, http: this.server });
        return this.server;
    }
    /**
     * Startup server message based on current server configuration.
     *
     * @returns Server message string.
     */
    getServerStartupMessage() {
        return `Furi Server (v${API_VERSION}) started.`;
    }
    /**
     * Startup Server info message based on current server configuration.
     *
     * @returns Server configuration string.
     */
    getServerInfoMessage() {
        const { env, port, host } = this.furiConfig.server;
        return `Server { host: ${host}, port: ${port}, mode: ${env} }`;
    }
    /**
     * Startup Logger info message based on current server configuration.
     *
     * @returns Logger configuration string.
     */
    getLoggerInfoMessage() {
        const { enabled, flushPeriod, logFile, maxCount, mode, level } = this.furiConfig.logger;
        return `Logger { enabled: ${enabled}, level: ${level}, logFile: ${logFile}, mode: ${mode}, flushPeriod: ${flushPeriod}ms, maxCount: ${maxCount} }`;
    }
    /**
     * Startup runtime info Furi is running under.
     *
     * @returns Runtime info string.
     */
    getRuntimeMessage() {
        let runtimeMessage;
        if (dntShim.dntGlobalThis.Deno) {
            const { deno, v8, typescript } = dntShim.dntGlobalThis.Deno.version;
            runtimeMessage = `Runtime { deno: ${deno}, v8: ${v8}, typescript: ${typescript} }`;
        }
        else {
            const { node, v8 } = process.versions;
            runtimeMessage = `Runtime { node: ${node}, v8: ${v8} }`;
        }
        return runtimeMessage;
    }
    /**
     * Register cleanup handler to be called during server shutdown.
     *
     * @param callback Cleanup Function to call.
     */
    preShutdown(callback) {
        this.cleanupHandler = callback;
    }
}
Object.defineProperty(Furi, "appStore", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: new StoreState()
});
Object.defineProperty(Furi, "httpServer", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: []
});
Object.defineProperty(Furi, "BodyParser", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: BodyParserFn
});
Object.defineProperty(Furi, "JSONBodyParser", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: JSONBodyParserFn
});
Object.defineProperty(Furi, "UrlEncodedParser", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: UrlEncodedParserFn
});
