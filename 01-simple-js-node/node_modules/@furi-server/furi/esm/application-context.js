/**
 * Furi - Fast Uniform Resource Identifier.
 *
 * The Fast and Furious Node.js Router.
 * Copyright(c) 2016, 2025 Rajinder Yadav.
 *
 * Labs DevMentor.org Corp. <info@devmentor.org>
 * This code is released as-is without warranty under the "GNU GENERAL PUBLIC LICENSE".
 */
/**
 * An initialized Application Context object is passed to
 * each middleware and request handler. It provides helper
 * functions to simplify working with Request and Response objects.
 * It also helps manage application state and session state.
 */
export class ApplicationContext {
    constructor(appStore, request, response) {
        Object.defineProperty(this, "appStore", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: appStore
        });
        Object.defineProperty(this, "request", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: request
        });
        Object.defineProperty(this, "response", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: response
        });
        // Init request session data.
        this.request.sessionData = {};
    }
    /**
     * Parse query string into an object.
     *
     * @param ctx:    Application context object.
     * @param simple  true will parse all values as a string,
     *                false will parse a value as a string or number.
     * @returns Parsed query string as an object, or null if no valid query parameters are found.
     */
    queryStringToObject(simple = true) {
        const queryParams = this.request?.query;
        const resultObj = {};
        queryParams?.forEach((v, k) => {
            const arr = v.split(',');
            if (simple) {
                // Params to Object with string values.
                resultObj[k] = arr.length > 1 ? arr : v;
            }
            else {
                // Params to Object with string or number values.
                const value = v !== '' ? Number(v) : NaN;
                resultObj[k] = arr.length > 1 ? arr : (isNaN(value) ? v : value);
            }
        });
        return resultObj;
    }
    sessionState(key, value) {
        if (value) {
            this.request.sessionData[key] = value;
        }
        else {
            return this.request.sessionData[key];
        }
    }
    storeState(key, value) {
        if (value) {
            this.appStore.storeState(key, value);
        }
        else {
            return this.appStore.storeState(key);
        }
    }
    /**
     * Fetch cookie from request header.
     *
     * @return Cookie value or undefined if not found.
     */
    getCookie() {
        return this.request.headers['cookie'];
    }
    /**
     * Set cookies in response header. This function may be called
     * multiple times to set multiple cookies.
     *
     * @param name Cookie name.
     * @param value Cookie value.
     * @return void.
     */
    setCookie(name, value) {
        const cookies = this.response.getHeader('Set-Cookie');
        if (!cookies) {
            this.response.setHeader('Set-Cookie', `${name}=${value};`);
        }
        else {
            this.response.setHeader('Set-Cookie', `${cookies} ${name}=${value};`);
        }
    }
    requestHeader(name, value) {
        if (value) {
            this.request.headers[name] = value;
        }
        else {
            return this.request.headers[name];
        }
    }
    requestHeaders() {
        return this.request.headers;
    }
    responseHeader() {
        if (arguments[0] instanceof Headers) {
            this.response.setHeaders(arguments[0]);
        }
        else if (arguments.length === 1) {
            return this.response.getHeader(arguments[0]);
        }
        else if (arguments.length === 2) {
            this.response.setHeader(arguments[0], arguments[1]);
        }
    }
    send(data, encoding) {
        const bufferEncoding = encoding ?? 'utf8';
        if (typeof data === 'string') {
            this.response.write(data, bufferEncoding);
        }
        else {
            this.response.write(JSON.stringify(data), bufferEncoding);
        }
    }
    end(data) {
        if (!data) {
            this.response.end();
        }
        else if (typeof data === 'string') {
            this.response.end(data);
        }
        else {
            this.response.end(JSON.stringify(data));
        }
    }
}
;
