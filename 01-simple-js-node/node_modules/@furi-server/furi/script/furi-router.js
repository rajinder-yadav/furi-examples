"use strict";
/**
 * Furi - Fast Uniform Resource Identifier.
 *
 * The Fast and Furious Node.js Router.
 * Copyright(c) 2016, 2025 Rajinder Yadav.
 *
 * Labs DevMentor.org Corp. <info@devmentor.org>
 * This code is released as-is without warranty under the "GNU GENERAL PUBLIC LICENSE".
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FuriRouter = void 0;
const node_path_1 = __importDefault(require("node:path"));
const types_js_1 = require("./types.js");
const application_context_js_1 = require("./application-context.js");
const furi_js_1 = require("./furi.js");
const TopLevelMiddleware = '/';
/**
 * The FuriRouter class is responsible for two things:
 *
 * 1. The creation of the route table.
 *
 * 2. Routing HTTP requests to middlewares and the appropriate
 *    request handler based on the URI and method.
 *
 * In the process it will parse segment names for named routes.
 */
class FuriRouter {
    constructor() {
        Object.defineProperty(this, "httpMethodMap", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        // Initialize HTTP Router lookup maps.
        Object.keys(types_js_1.HttpMapIndex).forEach(() => {
            this.httpMethodMap.push({ namedRoutePartitionMap: {}, staticRouteMap: {} });
        });
    }
    use() {
        if (arguments.length === 0) {
            throw new Error('No Middleware callback function provided');
        }
        if ((0, types_js_1.isTypeRouterConfig)(arguments[0]) || (0, types_js_1.isTypeRouterConfig)(arguments[1])) {
            // Type is a router array
            let pathPrefix = '';
            let routerConfig = null;
            if (typeof arguments[0] === 'string') {
                pathPrefix = arguments[0];
                routerConfig = arguments[1];
            }
            else {
                routerConfig = arguments[0];
            }
            // Add top-level middleswares.
            if (routerConfig?.middleware && routerConfig.middleware.length > 0) {
                this.buildRequestMap(types_js_1.HttpMapIndex.MIDDLEWARE, TopLevelMiddleware, routerConfig.middleware);
            }
            // Add route handlers.
            if (routerConfig?.routes && routerConfig.routes.length > 0) {
                for (const route of routerConfig.routes) {
                    // const ClassRef: HandlerFunction | HandlerFunction[] | RouterHanderConstructor<BaseRouterHandler>  = route.controller;
                    const ClassRef = route.controller;
                    let handlers = null;
                    if (ClassRef && typeof ClassRef === 'function' && ClassRef.prototype instanceof types_js_1.BaseRouterHandler) {
                        const ClassRouterHandlerRef = ClassRef;
                        handlers = [(new ClassRouterHandlerRef()).handle];
                    }
                    else if (Array.isArray(route.controller)) {
                        handlers = route.controller;
                    }
                    else {
                        handlers = [route.controller];
                    }
                    const routePath = node_path_1.default.join(pathPrefix, route.path).replace(/\/$/, '');
                    switch (route.method.toLowerCase()) {
                        case 'get':
                            this.buildRequestMap(types_js_1.HttpMapIndex.GET, routePath, handlers);
                            break;
                        case 'post':
                            this.buildRequestMap(types_js_1.HttpMapIndex.POST, routePath, handlers);
                            break;
                        case 'put':
                            this.buildRequestMap(types_js_1.HttpMapIndex.PUT, routePath, handlers);
                            break;
                        case 'patch':
                            this.buildRequestMap(types_js_1.HttpMapIndex.PATCH, routePath, handlers);
                            break;
                        case 'delete':
                            this.buildRequestMap(types_js_1.HttpMapIndex.DELETE, routePath, handlers);
                            break;
                        case 'all':
                            this.all(routePath, ...handlers);
                            break;
                        default:
                            throw new Error(`Invalid HTTP method: ${route.method}`);
                    }
                }
            }
            return this;
        }
        else if (arguments[0] instanceof FuriRouter) {
            // Mounting router as top level middleware.
            this.mergeRouterMaps(arguments[0].httpMethodMap);
            return this;
        }
        else if (arguments[1] instanceof FuriRouter) {
            // Mounting router to a path.
            const uri = arguments[0];
            const routeMap = arguments[1].httpMethodMap;
            // Map all keys from supplied router with a prefix and save to this router map.
            for (let mapIndex = 0; mapIndex < routeMap.length; ++mapIndex) {
                // Map static paths.
                for (const [keySrc, staticRouteMap] of Object.entries(routeMap[mapIndex].staticRouteMap)) {
                    const keyDest = mapIndex === types_js_1.HttpMapIndex.MIDDLEWARE ? keySrc : node_path_1.default.join(uri, keySrc).replace(/\/$/, '');
                    this.buildRequestMap(mapIndex, keyDest, staticRouteMap.callbacks);
                }
                // Map named paths.
                for (const [bucket, namedRoutePartitionMap] of Object.entries(routeMap[mapIndex].namedRoutePartitionMap)) {
                    const routes = routeMap[mapIndex].namedRoutePartitionMap[bucket].length;
                    for (let routeIndex = 0; routeIndex < routes; ++routeIndex) {
                        const keySrc = routeMap[mapIndex].namedRoutePartitionMap[bucket][routeIndex].pathNames.join('/');
                        const keyDest = node_path_1.default.join(uri, keySrc).replace(/\/$/, '');
                        this.buildRequestMap(mapIndex, keyDest, namedRoutePartitionMap[routeIndex].callbacks);
                    }
                }
            }
            return this;
        }
        else if (typeof arguments[0] === 'string') {
            // Route based middleware.
            const uri = arguments[0];
            const callbacks = Array.from(arguments).slice(1);
            if (callbacks.length === 0) {
                throw new Error('No middleware callback function provided');
            }
            return this.all(uri, ...callbacks);
        }
        // Top level based middleware.
        return this.buildRequestMap(types_js_1.HttpMapIndex.MIDDLEWARE, TopLevelMiddleware, Array.from(arguments));
    }
    /**
     * Assign Request handler to all HTTP lookup maps.
     *
     * @param uri  String value of URI.
     * @param fn   Reference to callback functions of type RequestHandlerFunc.
     * @returns    Reference to self, allows method chaining.
     */
    all(uri, ...fn) {
        // Skip Middleware Map.
        if (fn.length === 0) {
            throw new Error('No callback function provided');
        }
        // TODO: Delete once functional testing complete.
        // this.get(uri, ...fn);
        // this.post(uri, ...fn);
        // this.put(uri, ...fn);
        // this.patch(uri, ...fn);
        // this.delete(uri, ...fn);
        const count = Object.keys(types_js_1.HttpMapIndex).length;
        for (let mapIndex = 0; mapIndex < count; ++mapIndex) {
            if (mapIndex === types_js_1.HttpMapIndex.MIDDLEWARE) {
                continue;
            }
            this.buildRequestMap(mapIndex, uri, fn);
        }
        return this;
    }
    /**
     * Assign a HTTP GET handler to the provided URI lookup map.
     *
     * @param uri  String value of URI.
     * @param fn   Reference to callback functions of type RequestHandlerFunc.
     * @returns    Reference to self, allows method chaining.
     */
    get(uri, ...fn) {
        if (fn.length === 0) {
            throw new Error('No callback function provided');
        }
        return this.buildRequestMap(types_js_1.HttpMapIndex.GET, uri, fn);
    }
    /**
     * Assign a HTTP PATCH handler to the provided URI lookup map.
     *
     * @param uri  String value of URI.
     * @param fn   Reference to callback functions of type RequestHandlerFunc.
     * @returns    Reference to self, allows method chaining.
     */
    patch(uri, ...fn) {
        if (fn.length === 0) {
            throw new Error('No callback function provided');
        }
        return this.buildRequestMap(types_js_1.HttpMapIndex.PATCH, uri, fn);
    }
    /**
     * Assign a HTTP POST handler to the provided URI lookup map.
     *
     * @param uri  String value of URI.
     * @param fn   Reference to callback functions of type RequestHandlerFunc.
     * @returns    Reference to self, allows method chaining.
     */
    post(uri, ...fn) {
        if (fn.length === 0) {
            throw new Error('No callback function provided');
        }
        return this.buildRequestMap(types_js_1.HttpMapIndex.POST, uri, fn);
    }
    /**
     * Assign a HTTP PUT handler to the provided URI lookup map.
     *
     * @param uri  String value of URI.
     * @param fn   Reference to callback functions of type RequestHandlerFunc.
     * @returns    Reference to self, allows method chaining.
     */
    put(uri, ...fn) {
        if (fn.length === 0) {
            throw new Error('No callback function provided');
        }
        return this.buildRequestMap(types_js_1.HttpMapIndex.PUT, uri, fn);
    }
    /**
     * Assign a HTTP DELETE handler to the provided URI lookup map.
     *
     * @param uri  String value of URI.
     * @param fn   Reference to callback functions of type RequestHandlerFunc.
     * @returns    Reference to self, allows method chaining.
     */
    delete(uri, ...fn) {
        if (fn.length === 0) {
            throw new Error('No callback function provided');
        }
        return this.buildRequestMap(types_js_1.HttpMapIndex.DELETE, uri, fn);
    }
    /**
     * Node requires a handler function for incoming HTTP request.
     * This handler function is usually passed to createServer().
     *
     * @returns Reference to request handler function.
     */
    handler() {
        return this.dispatch.bind(this);
    }
    /**
     * Dispatches incoming HTTP requests to the appropriate handler function.
     *
     * @param incomingMessage HTTP request.
     * @param response        HTTP response.
     * @returns void.
     */
    dispatch(incomingMessage, response) {
        // LOG_DEBUG( request.method, request.url );
        const request = new types_js_1.HttpRequest(incomingMessage);
        if (furi_js_1.Furi.bufferedLogger) {
            furi_js_1.Furi.bufferedLogger.info(`host: ${request.headers.host}, remote-ip: ${request.socket.remoteAddress}, remote-port: ${request.socket.remotePort}, http: ${request.httpVersion}, method: ${request.method}, url: ${request.url}`);
        }
        switch (request.method) {
            case 'GET':
            case 'get':
                this.processHTTPMethod(types_js_1.HttpMapIndex.GET, request, response);
                break;
            case 'POST':
            case 'post':
                this.processHTTPMethod(types_js_1.HttpMapIndex.POST, request, response);
                break;
            case 'PUT':
            case 'put':
                this.processHTTPMethod(types_js_1.HttpMapIndex.PUT, request, response);
                break;
            case 'PATCH':
            case 'patch':
                this.processHTTPMethod(types_js_1.HttpMapIndex.PATCH, request, response);
                break;
            case 'DELETE':
            case 'delete':
                this.processHTTPMethod(types_js_1.HttpMapIndex.DELETE, request, response);
                break;
            default:
                response.writeHead(501, 'HTTP Dispatch method not implemented', {
                    'Content-Type': 'text/plain',
                    'User-Agent': furi_js_1.Furi.getApiVersion()
                });
                console.error(`HTTP method ${request.method} is not supported.`);
                response.end();
        } // switch
    }
    /**
     * Convert named segments path to a RegEx key and collect segment names.
     *
     * URI    => /aa/:one/bb/cc/:two/e
     * KEY    => /aa/(\w+)/bb/cc/(\w+)/e
     * params => ['one', 'two']
     * return => { params: ['one', 'two'], key: '/aa/(\w+)/bb/cc/(\w+)/e' }
     *
     * @param  pathNames URI with segment names.
     * @return Object with regex key and array with param names.
     */
    createSearchKeyFromNamedRoute(pathNames) {
        if (pathNames.length === 0) {
            return { params: [], key: '' };
        }
        const params = [];
        let key = '';
        for (const pathName of pathNames) {
            if (pathName.startsWith(':')) {
                params.push(pathName.substring(1));
                key = `${key}/([\\w-.~]+)`;
            }
            else {
                key = `${key}/${pathName}`;
            }
        }
        return { params: params, key: key.substring(1) };
    }
    /**
     * Match URI with named path and attaches param object containing
     * the property of each named param and its value on the request object.
     *
     * @param uri Path URI to be matched.
     * @param pk  Path object with RegEx key and segments.
     * @return    null If URI doesn't match Path Object.
     * @return    param Object containing property and its value for each segment from Path object.
     */
    regexPathMatch(uri, pk, request) {
        if (!pk.params || !pk.key) {
            return false;
        }
        const pat = RegExp(pk.key);
        const match = pat.exec(uri);
        if (match) {
            // LOG_DEBUG( 'URI with segment(s) matched: ' + JSON.stringify( pk ) );
            for (let i = 0; i < pk.params.length; ++i) {
                const paramName = pk.params[i];
                request.params[paramName] = match[i + 1];
            }
            // LOG_DEBUG( `params: ${ JSON.stringify( request.params ) }` );
            return true;
        }
        return false;
    }
    /**
     * Build HTTP Request handler mappings and assign callback function
     *
     * @param mapIndex  The URI Map used to look up callbacks.
     * @param uri       String value of URI.
     * @param handlers  Reference to callback functions of type RequestHandlerFunc.
     * @returns         Reference to self, allows method chaining.
     */
    buildRequestMap(mapIndex, uri, handlers) {
        // LOG_DEBUG(uri);
        const routeMap = this.httpMethodMap[mapIndex];
        /**
         * https://tools.ietf.org/html/rfc3986
         * Static URI characters
         */
        const regexCheckStaticURL = /^\/?([~\w/.-]+)\/?$/;
        const useDirectLookup = regexCheckStaticURL.test(uri);
        const callbacks = handlers.flat(Infinity);
        /**
         * Check if URI is a static path.
         */
        if (useDirectLookup) {
            // Static path, we can use direct lookup.
            if (!routeMap.staticRouteMap[uri]) {
                routeMap.staticRouteMap[uri] = { callbacks };
            }
            else {
                // chain callbacks for same URI path.
                routeMap.staticRouteMap[uri].callbacks.push(...callbacks);
            }
        }
        else {
            // Dynamic path with named parameters or Regex path.
            const regexCheckNamedPath = /^\/?([:~\w/.-]+)\/?$/;
            const useRegex = !regexCheckNamedPath.test(uri);
            // Remove leading and trailing slash '/'.
            const pathNames = uri.replace(/(^\/)|(\/$)/g, '').split('/');
            // Partition by '/' count, optimize lookup.
            const bucket = pathNames.length;
            const { key, params } = this.createSearchKeyFromNamedRoute(pathNames);
            // LOG_DEBUG('regex>', useRegex, '\tpathNames>', pathNames);
            // LOG_DEBUG('key>', key, '\tparams>', >', params);
            if (!routeMap.namedRoutePartitionMap[bucket]) {
                routeMap.namedRoutePartitionMap[bucket] = [{ key, params, callbacks, pathNames, useRegex }];
            }
            else {
                routeMap.namedRoutePartitionMap[bucket].push({ key, params, callbacks, pathNames, useRegex });
            }
        }
        return this;
    }
    /**
     * Execute all top level middlewares.
     * @param applicationContext Application context object.
     * @return void.
     */
    callTopLevelMiddlewares(applicationContext) {
        const middlewareMap = this.httpMethodMap[types_js_1.HttpMapIndex.MIDDLEWARE];
        const middleware_chain = middlewareMap.staticRouteMap[TopLevelMiddleware]?.callbacks;
        if (!middleware_chain || middleware_chain?.length === 0) {
            return;
        }
        let callbackMiddlewareIndex = 0;
        const nextMiddleware = () => {
            if (callbackMiddlewareIndex < middleware_chain.length) {
                const callback = middleware_chain[callbackMiddlewareIndex++];
                const rv = callback(applicationContext, nextMiddleware);
                if (rv) {
                    applicationContext.end(rv);
                    return;
                }
            }
        };
        nextMiddleware();
    }
    /**
     * Check if each path name matches its ordinal key value,
     * named path params are attached to request.params.
     *
     * @param pathNames Array of path segments.
     * @param keyNames  Array of key names.
     * @param request   HttpRequest object.
     * @returns boolean True if all tokens match, otherwise false.
     */
    fastPathMatch(pathNames, keyNames, request) {
        // LOG_DEBUG('pathNames>', pathNames);
        // LOG_DEBUG('keyNames>  ', keyNames);
        if (keyNames.length !== pathNames.length) {
            return false;
        }
        // LOG_DEBUG('Equal token count');
        for (let i = pathNames.length - 1; i >= 0; i--) {
            if (pathNames[i] !== keyNames[i] && keyNames[i][0] !== ':') {
                return false;
            }
            else if (keyNames[i][0] === ':') {
                // remove ':' from start of string.
                const key = keyNames[i].substring(1);
                request.params[key] = pathNames[i];
                // LOG_DEBUG(`param ${keyNames[i]}=${pathNames[i]}`);
            }
        }
        return true;
    }
    /**
     * This method calls the callbacks for the mapped URL if it exists.
     * If one does not exist a HTTP status error code is returned.
     *
     * @param mapIndex  The URI Map used to look up callbacks.
     * @param request   Reference to Node request object (IncomingMessage).
     * @param response  Reference to Node response object (ServerResponse).
     * @return void.
     */
    processHTTPMethod(mapIndex, request, response, throwOnNotFound = true) {
        const routeMap = this.httpMethodMap[mapIndex];
        let URL = request.url;
        /** URL strip rules:
         * Remove trailing slash '/'
         * Parse query string and fragment.
         */
        const urlQuery = URL.split('?');
        if (urlQuery.length > 1 && urlQuery[1].length > 0) {
            request.query = new URLSearchParams(urlQuery[1]);
        }
        URL = urlQuery[0];
        // Remove trailing slash '/' from URL.
        if (URL.length > 1 && URL[URL.length - 1] === '/') {
            URL = URL.substring(0, URL.length - 1);
        }
        /**
         * Setup helper functions on application context object.
         */
        const applicationContext = new application_context_js_1.ApplicationContext(furi_js_1.Furi.appStore, request, response);
        try {
            if (routeMap.staticRouteMap[URL]) {
                // Found direct match of static URI path.
                this.callTopLevelMiddlewares(applicationContext);
                // Execute path callback chain.
                const callback_chain = routeMap.staticRouteMap[URL]?.callbacks;
                if (!callback_chain || callback_chain?.length === 0) {
                    return;
                }
                let callbackIndex = 0;
                const nextStatic = () => {
                    if (callbackIndex < callback_chain.length) {
                        const callback = callback_chain[callbackIndex++];
                        const rv = callback(applicationContext, nextStatic);
                        if (rv) {
                            applicationContext.end(rv);
                            return;
                        }
                    }
                };
                return nextStatic();
            }
            else if (routeMap.namedRoutePartitionMap) {
                // Search for named parameter URI or RegEx path match.
                const pathNames = URL.replace(/(^\/)|(\/$)/g, '').split('/');
                // Partition index.
                const bucket = pathNames.length;
                // LOG_DEBUG('pathNames>', pathNames);
                // LOG_DEBUG('bucket>', bucket);
                if (routeMap.namedRoutePartitionMap[bucket]) {
                    if (!request.params) {
                        request.params = {};
                    }
                    const namedRouteCallbacks = routeMap.namedRoutePartitionMap[bucket];
                    if (!namedRouteCallbacks || namedRouteCallbacks?.length === 0) {
                        return;
                    }
                    for (const namedRouteCallback of namedRouteCallbacks) {
                        if (!namedRouteCallback.useRegex && this.fastPathMatch(pathNames, namedRouteCallback.pathNames, request) ||
                            namedRouteCallback.useRegex && this.regexPathMatch(URL, namedRouteCallback, request)) {
                            // LOG_DEBUG(`params: ${JSON.stringify(request.params)}`);
                            this.callTopLevelMiddlewares(applicationContext);
                            // Execute path callback chain.
                            if (namedRouteCallback?.callbacks.length > 0) {
                                let callbackNamedRouteIndex = 0;
                                const nextNamedRoute = () => {
                                    if (callbackNamedRouteIndex < namedRouteCallback.callbacks.length) {
                                        const callback = namedRouteCallback.callbacks[callbackNamedRouteIndex++];
                                        const rv = callback(applicationContext, nextNamedRoute);
                                        if (rv) {
                                            return applicationContext.end(rv);
                                        }
                                    }
                                };
                                return nextNamedRoute();
                            }
                        }
                    } // for
                }
                else if (throwOnNotFound) {
                    // throw new Error(`Route not found for ${URL}`);
                    (0, types_js_1.LOG_WARN)(`Route not found for ${URL}`);
                    response.writeHead(404, {
                        'Content-Type': 'text/plain',
                        'User-Agent': furi_js_1.Furi.getApiVersion(),
                    });
                    response.end('Route not found');
                    return;
                }
            }
        }
        catch (_ex) {
            (0, types_js_1.LOG_ERROR)('URI Not Found.');
            response.writeHead(404, {
                'Content-Type': 'text/plain',
                'User-Agent': furi_js_1.Furi.getApiVersion(),
            });
            response.end('Route not found');
            return;
        }
        if (throwOnNotFound) {
            // throw new Error(`Route not found for ${URL}`);
            (0, types_js_1.LOG_WARN)(`Route not found for ${URL}`);
            // response.statusCode = 404;
            // response.statusMessage = 'Route not found';
            response.writeHead(404, {
                'Content-Type': 'text/plain',
                'User-Agent': furi_js_1.Furi.getApiVersion(),
            });
            response.end('Route not found');
        }
    }
    /**
     * Merge given router maps into existing top-level router map.
     * This will occur when the caller adds a route-less router middleware.
     *
     * @param routeMap RouteMap[] to merge into the current httpMaps.
     * @return void
     */
    mergeRouterMaps(routeMap) {
        for (let mapIndex = 0; mapIndex < routeMap.length; ++mapIndex) {
            // Static route map.
            if (Object.keys(this.httpMethodMap[mapIndex].staticRouteMap).length === 0) {
                // Static route map is empty, so we can just merge a new map.
                this.httpMethodMap[mapIndex].staticRouteMap = {};
            }
            for (const [key, staticRouteMap] of Object.entries(routeMap[mapIndex].staticRouteMap)) {
                if (this.httpMethodMap[mapIndex].staticRouteMap[key]?.callbacks.length > 0) {
                    this.httpMethodMap[mapIndex].staticRouteMap[key].callbacks.push(...staticRouteMap.callbacks);
                }
                else {
                    this.httpMethodMap[mapIndex].staticRouteMap[key] = staticRouteMap;
                }
            }
            // Named route map is empty, so we can just merge a new map.
            for (const [bucket, namedRoutePartitionMap] of Object.entries(routeMap[mapIndex].namedRoutePartitionMap)) {
                if (!this.httpMethodMap[mapIndex].namedRoutePartitionMap[bucket]) {
                    this.httpMethodMap[mapIndex].namedRoutePartitionMap[bucket] = [];
                }
                for (const namedRouteCallback of namedRoutePartitionMap) {
                    this.httpMethodMap[mapIndex].namedRoutePartitionMap[bucket].push(namedRouteCallback);
                }
            }
        }
    }
}
exports.FuriRouter = FuriRouter;
