"use strict";
/**
 * Furi - Fast Uniform Resource Identifier.
 *
 * The Fast and Furious Node.js Router.
 * Copyright(c) 2016, 2025 Rajinder Yadav.
 *
 * Labs DevMentor.org Corp. <info@devmentor.org>
 * This code is released as-is without warranty under the "GNU GENERAL PUBLIC LICENSE".
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseRouterHandler = exports.HttpResponse = exports.HttpRequest = exports.LogLevelsRank = exports.LogLevels = exports.HttpMapIndex = exports.LOG_ERROR = exports.LOG_WARN = exports.LOG_LOG = exports.LOG_INFO = exports.LOG_DEBUG = exports.API_VERSION = void 0;
exports.mapToLogLevelRank = mapToLogLevelRank;
exports.isTypeRouterConfig = isTypeRouterConfig;
exports.ClassHandler = ClassHandler;
const node_http_1 = require("node:http");
const furi_js_1 = require("./furi.js");
/**
 * API Version.
 */
exports.API_VERSION = '0.4.1';
/**
 * Logging helper functions.
 */
const LOG_DEBUG = (msg) => { if (furi_js_1.Furi.fastLogger) {
    furi_js_1.Furi.fastLogger.debug(msg);
} };
exports.LOG_DEBUG = LOG_DEBUG;
const LOG_INFO = (msg) => { if (furi_js_1.Furi.fastLogger) {
    furi_js_1.Furi.fastLogger.info(msg);
} };
exports.LOG_INFO = LOG_INFO;
const LOG_LOG = (msg) => { if (furi_js_1.Furi.fastLogger) {
    furi_js_1.Furi.fastLogger.log(msg);
} };
exports.LOG_LOG = LOG_LOG;
const LOG_WARN = (msg) => { if (furi_js_1.Furi.fastLogger) {
    furi_js_1.Furi.fastLogger.warm(msg);
} };
exports.LOG_WARN = LOG_WARN;
const LOG_ERROR = (msg) => { if (furi_js_1.Furi.fastLogger) {
    furi_js_1.Furi.fastLogger.error(msg);
} };
exports.LOG_ERROR = LOG_ERROR;
/**
 * Enumerated keys for HTTP Maps. The keys are used to partition
 * HTTP methods, to optimized lookup.
 */
exports.HttpMapIndex = {
    MIDDLEWARE: 0,
    GET: 1,
    POST: 2,
    PUT: 3,
    PATCH: 4,
    DELETE: 5
};
/**
 * Log level string litaral values for log messages and configuration.
 */
exports.LogLevels = {
    DEBUG: 'DEBUG',
    INFO: 'INFO',
    LOG: 'LOG',
    WARN: 'WARN',
    ERROR: 'ERROR',
    CRITICAL: 'CRITICAL',
    FATAL: 'FATAL'
};
/**
 * Log level ordinal values use for filtering log messages.
 */
exports.LogLevelsRank = {
    DEBUG: 0,
    INFO: 1,
    LOG: 2,
    WARN: 3,
    ERROR: 4,
    CRITICAL: 5,
    FATAL: 6
};
/**
 * Converts a log level string to its ordinal value to help with log filtering.
 *
 * @param logLevel - The log level as a string.
 * @returns Log level ordinal value.
 */
function mapToLogLevelRank(logLevel) {
    switch (logLevel.toUpperCase()) {
        case 'DEBUG':
            return exports.LogLevelsRank.DEBUG;
        case 'INFO':
            return exports.LogLevelsRank.INFO;
        case 'LOG':
            return exports.LogLevelsRank.LOG;
        case 'WARN':
            return exports.LogLevelsRank.WARN;
        case 'ERROR':
            return exports.LogLevelsRank.ERROR;
        case 'CRITICAL':
            return exports.LogLevelsRank.CRITICAL;
        case 'FATAL':
            return exports.LogLevelsRank.FATAL;
        default:
            throw new Error(`Invalid log level: ${logLevel}`);
    }
}
/**
 * HTTP Request object extending Node.js IncomingMessage.
 */
class HttpRequest extends node_http_1.IncomingMessage {
    constructor(incomingMessage) {
        super(incomingMessage instanceof node_http_1.IncomingMessage
            ? incomingMessage.socket :
            incomingMessage);
        Object.defineProperty(this, "params", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(this, "query", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
        });
        Object.defineProperty(this, "sessionData", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(this, "app", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
        });
        Object.defineProperty(this, "body", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
        });
        if (incomingMessage instanceof node_http_1.IncomingMessage) {
            Object.assign(this, incomingMessage);
        }
    }
}
exports.HttpRequest = HttpRequest;
/**
 * HTTP Response object extending Node.js ServerResponse.
 */
class HttpResponse extends node_http_1.ServerResponse {
}
exports.HttpResponse = HttpResponse;
/**
 * Base class for Class based router handlers.
 */
class BaseRouterHandler {
}
exports.BaseRouterHandler = BaseRouterHandler;
/**
 * Helper function to check type Routes.
 * Properties 'middleware' or 'routes' are optional, but not both.
 */
function isTypeRouterConfig(value) {
    const middleswares = typeof value === 'object'
        && value !== null
        && 'middleware' in value
        && Array.isArray(value.middleware);
    const routes = typeof value === 'object'
        && value !== null
        && 'routes' in value
        && Array.isArray(value.routes);
    return middleswares || routes;
}
/**
 * Create and instance of the class and return bound handler function.
 *
 * @param ClassRef
 * @returns handler function bound to instace of the class.
 */
function ClassHandler(ClassRef) {
    if (ClassRef && typeof ClassRef === 'function' && ClassRef.prototype instanceof BaseRouterHandler) {
        const ClassRouterHandlerRef = ClassRef;
        const instanceRef = new ClassRouterHandlerRef();
        return instanceRef.handle.bind(instanceRef);
    }
    throw new Error("Invalid class reference. Please provide a valid class that extends BaseRouterHandler.");
}
