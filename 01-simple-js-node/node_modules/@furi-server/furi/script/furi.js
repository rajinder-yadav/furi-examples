"use strict";
/**
 * Furi - Fast Uniform Resource Identifier.
 *
 * The Fast and Furious Node.js Router.
 * Copyright(c) 2016, 2025 Rajinder Yadav.
 *
 * Labs DevMentor.org Corp. <info@devmentor.org>
 * This code is released as-is without warranty under the "GNU GENERAL PUBLIC LICENSE".
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Furi = void 0;
// deno-lint-ignore-file no-explicit-any
const dntShim = __importStar(require("./_dnt.shims.js"));
const fs = __importStar(require("node:fs"));
const http = __importStar(require("node:http"));
const node_process_1 = __importDefault(require("node:process"));
const yaml_1 = __importDefault(require("yaml"));
const furi_router_js_1 = require("./furi-router.js");
const types_js_1 = require("./types.js");
const state_js_1 = require("./state.js");
const fast_logger_js_1 = require("./utils/fast-logger.js");
const body_parser_js_1 = require("./utils/body-parser.js");
// Re-export types and classes for applications
__exportStar(require("./types.js"), exports);
__exportStar(require("./application-context.js"), exports);
__exportStar(require("./furi-router.js"), exports);
__exportStar(require("./utils/http-cookies-store.js"), exports);
__exportStar(require("./utils/time-period.js"), exports);
/**
 * Handler Linux signal to perform clean shutdown.
 */
node_process_1.default.once('SIGINT', () => {
    Furi.shutDown(5000);
});
/**
 * Router Class, matches URI for fast dispatch to handler.
 */
class Furi extends furi_router_js_1.FuriRouter {
    constructor() {
        super();
        Object.defineProperty(this, "server", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
        });
        Object.defineProperty(this, "properties", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        // Shutdown cleanup handler callback.
        Object.defineProperty(this, "cleanupHandler", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
        });
        // Default server configuration.
        Object.defineProperty(this, "furiConfig", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {
                server: {
                    env: 'development',
                    port: 3030,
                    host: 'localhost',
                    callback: null,
                },
                logger: {
                    enabled: false,
                    terminal: false,
                    flushPeriod: 1000,
                    logFile: 'furi.log',
                    maxCount: 100,
                    mode: 'stream',
                    level: types_js_1.LogLevels.INFO,
                },
            }
        });
        // Read default configuration values.
        let { env, port, host, callback } = this.furiConfig.server;
        let { enabled, terminal, flushPeriod, maxCount, mode, logFile, level } = this.furiConfig.logger;
        /**
         * Read server configuration properties from furi.yaml or furi.yml file.
         */
        try {
            let data = null;
            if (fs.existsSync('./furi.yaml') && fs.statSync('./furi.yaml').isFile()) {
                data = fs.readFileSync('./furi.yaml', 'utf8');
            }
            else if (fs.existsSync('./furi.yml') && fs.statSync('./furi.yml').isFile()) {
                data = fs.readFileSync('./furi.yml', 'utf8');
            }
            if (data !== null) {
                // Server values.
                this.properties = yaml_1.default.parse(data);
                if (this.properties.server) {
                    port = this.properties.server.port ?? port;
                    host = this.properties.server.host ?? host;
                    env = this.properties.server.env ?? env;
                }
                // Logger values.
                if (this.properties.logger) {
                    enabled = this.properties.logger.enabled ?? enabled;
                    terminal = this.properties.logger.terminal ?? terminal;
                    flushPeriod = this.properties.logger.flushPeriod ?? flushPeriod;
                    maxCount = this.properties.logger.maxCount ?? maxCount;
                    mode = this.properties.logger.mode ?? mode;
                    logFile = this.properties.logger.logFile ?? logFile;
                    level = this.properties.logger.level?.toUpperCase() ?? level;
                }
                // Update configuration values.
                this.furiConfig = {
                    server: { env, port, host, callback },
                    logger: { enabled, terminal, flushPeriod, logFile, maxCount, mode, level },
                };
            }
            Furi.fastLogger = new fast_logger_js_1.FastLogger(node_process_1.default.cwd(), logFile, enabled, terminal, flushPeriod, maxCount, mode, level);
        }
        catch (error) {
            // Ignore and file errors.
            (0, types_js_1.LOG_ERROR)(`Furi::constructor error: ${JSON.stringify(error)}`);
        }
        this.furiConfig.server.callback = () => {
            const serverMessage = this.getServerStartupMessage();
            const serverInfoMessage = this.getServerInfoMessage();
            const loggerInfoMessage = this.getLoggerInfoMessage();
            const runtimeInfoMessage = this.getRuntimeMessage();
            if (Furi.fastLogger) {
                Furi.fastLogger.info(serverMessage);
                Furi.fastLogger.info(serverInfoMessage);
                Furi.fastLogger.info(runtimeInfoMessage);
                Furi.fastLogger.info(loggerInfoMessage);
            }
            console.log(serverMessage);
            console.log(serverInfoMessage);
            console.log(runtimeInfoMessage);
            console.log(loggerInfoMessage);
        };
    }
    /**
     * Class static method. Create instance of Router object.
     *
     * @returns Instance of class Furi.
     */
    static create() {
        // LOG_DEBUG(Furi.getApiVersion());
        return new Furi();
    }
    static info(message) {
        if (Furi.fastLogger) {
            Furi.fastLogger.info(message);
        }
    }
    /**
     * Perform clean shutdown.
     */
    static shutDown(exitTimer) {
        console.log();
        (0, types_js_1.LOG_INFO)('SIGINT signal received, goodbye!');
        (0, types_js_1.LOG_INFO)('Shutdown started...');
        // Close the HTTP server.
        // Close all Furi applications and their HTTP servers gracefully.
        Furi.httpServer.forEach((serverRef) => {
            (0, types_js_1.LOG_INFO)('Furi server shutting down...');
            if (serverRef.app.cleanupHandler) {
                (0, types_js_1.LOG_INFO)('Cleanup started...');
                serverRef.app.cleanupHandler();
                (0, types_js_1.LOG_INFO)('Cleanup completed.');
            }
            (0, types_js_1.LOG_INFO)('HTTP connection closing...');
            serverRef.http.close();
            (0, types_js_1.LOG_INFO)('HTTP connection closed.');
            (0, types_js_1.LOG_INFO)('Furi server shutdown completed.');
        });
        (0, types_js_1.LOG_INFO)('Shutdown completed.');
        if (Furi.fastLogger) {
            Furi.fastLogger.close();
        }
        // Delay to allow asynchronous processing to complete.
        setTimeout(() => {
            node_process_1.default.exit(1);
        }, exitTimer);
    }
    /**
     * Create a new router.
     * @return Instance of class FuriRouter.
     */
    static router() {
        return new furi_router_js_1.FuriRouter();
    }
    /**
     * Get Router API version.
     *
     * @returns API version as a string.
     */
    static getApiVersion() {
        return `Furi (v${types_js_1.API_VERSION})`;
    }
    /**
     * Start server with specified configuration.
     *
     * @param serverConfig  Configuration object for the server.
     * @returns Instance of http.Server.
     */
    listen(serverConfig) {
        let { env, port, host, callback } = serverConfig.server;
        // Update running server config properties.
        if (env) {
            this.furiConfig.server.env = env;
        }
        if (port) {
            this.furiConfig.server.port = port;
        }
        if (host) {
            this.furiConfig.server.host = host;
        }
        if (callback) {
            this.furiConfig.server.callback = callback;
        }
        if (!callback) {
            callback = this.furiConfig.server.callback;
        }
        const server = http.createServer(this.handler());
        if (port && host && callback) {
            server.listen(port, host, callback);
        }
        else if (port && callback) {
            server.listen(port, callback);
        }
        else if (port && host) {
            server.listen(port, host);
        }
        else {
            server.listen(port);
        }
        return server;
    }
    /**
     * Starts the Furi server with default or provided configuration.
     *
     * @returns Instance of http.Server.
     */
    start(_callback) {
        this.server = this.listen(this.furiConfig);
        // Node.js HTTP server list used to perform a clean close before exiting the process.
        Furi.httpServer.push({ app: this, http: this.server });
        return this.server;
    }
    /**
     * Startup server message based on current server configuration.
     *
     * @returns Server message string.
     */
    getServerStartupMessage() {
        return `Furi Server (v${types_js_1.API_VERSION}) started.`;
    }
    /**
     * Startup Server info message based on current server configuration.
     *
     * @returns Server configuration string.
     */
    getServerInfoMessage() {
        const { env, port, host } = this.furiConfig.server;
        return `Server { host: ${host}, port: ${port}, mode: ${env} }`;
    }
    /**
     * Startup Logger info message based on current server configuration.
     *
     * @returns Logger configuration string.
     */
    getLoggerInfoMessage() {
        const { enabled, flushPeriod, logFile, maxCount, mode, level } = this.furiConfig.logger;
        return `Logger { enabled: ${enabled}, level: ${level}, logFile: ${logFile}, mode: ${mode}, flushPeriod: ${flushPeriod}ms, maxCount: ${maxCount} }`;
    }
    /**
     * Startup runtime info Furi is running under.
     *
     * @returns Runtime info string.
     */
    getRuntimeMessage() {
        let runtimeMessage;
        if (dntShim.dntGlobalThis.Deno) {
            const { deno, v8, typescript } = dntShim.dntGlobalThis.Deno.version;
            runtimeMessage = `Runtime { deno: ${deno}, v8: ${v8}, typescript: ${typescript} }`;
        }
        else {
            const { node, v8 } = node_process_1.default.versions;
            runtimeMessage = `Runtime { node: ${node}, v8: ${v8} }`;
        }
        return runtimeMessage;
    }
    /**
     * Register cleanup handler to be called during server shutdown.
     *
     * @param callback Cleanup Function to call.
     */
    preShutdown(callback) {
        this.cleanupHandler = callback;
    }
}
exports.Furi = Furi;
Object.defineProperty(Furi, "appStore", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: new state_js_1.StoreState()
});
Object.defineProperty(Furi, "httpServer", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: []
});
Object.defineProperty(Furi, "BodyParser", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: body_parser_js_1.BodyParserFn
});
Object.defineProperty(Furi, "JSONBodyParser", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: body_parser_js_1.JSONBodyParserFn
});
Object.defineProperty(Furi, "UrlEncodedParser", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: body_parser_js_1.UrlEncodedParserFn
});
